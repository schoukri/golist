// Golist is a tool that generates 'Slice*' type wrappers for a given slice type T.
//
// Typically this process would be run using go generate, like this:
//
//	//go:generate golist -type=Foo
//
// running this command
//
//	golist -type=Foo
//
// in the same directory will create the file slice_foo.go
// containing a definition of
//
//	type SliceFoo struct {
//		data []Foo
//	}
//
// The default type is SliceT or sliceT (depending on if the type is exported)
// and output file is slice_t.go. This can be overridden with the -output flag.
//
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

type generator struct {
	packageName string
	outputName  string
	typeName    string
	sortable    bool
}

func (g *generator) generate() ([]byte, error) {

	var (
		t = template.Must(template.New("").Parse(tmpl))

		data = struct {
			Timestamp    time.Time
			PackageName  string
			TypeName     string
			OutputName   string
			VariableName string
			Sortable     bool
		}{
			time.Now().UTC(),
			g.packageName,
			g.typeName,
			g.outputName,
			strings.ToLower(string(g.outputName[0])),
			g.sortable,
		}

		buf bytes.Buffer
		err = t.Execute(&buf, data)
	)

	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("golist: ")

	var (
		typeName   = flag.String("type", "", "type name; must be set")
		outputName = flag.String("output", "", "output type and file name; default [s|S]lice<type> and srcdir/slice_<type>.go")
		sortable   = flag.Bool("sortable", true, "include the methods to implement Sort.Interface")
	)

	flag.Parse()

	if len(*typeName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	pkg, err := build.Default.ImportDir(".", 0)
	if err != nil {
		log.Fatal(err)
	}

	var (
		filename string
		g        generator
	)

	g.typeName = *typeName
	g.packageName = pkg.Name
	g.sortable = *sortable

	if len(*outputName) == 0 {
		// no output specified, use default golist_<type>

		// TODO: may not be the most reliable method
		exported := strings.Title(g.typeName) == g.typeName

		if exported {
			g.outputName = "Slice" + strings.Title(g.typeName)
		} else {
			g.outputName = "slice" + strings.Title(g.typeName)
		}
	} else {
		g.outputName = *outputName
	}
	filename = fmt.Sprintf("slice_%s.go", strings.ToLower(g.typeName))

	src, err := g.generate()
	if err != nil {
		log.Fatal(err)
	}

	if err = ioutil.WriteFile(filename, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

const tmpl = `// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at {{ .Timestamp }}.

package {{ .PackageName }}

import (
	"fmt"
	"math/rand"
	{{- if .Sortable }}
	"sort"
	{{- end }}
	"time"
)

// {{ .OutputName }} is a slice of type {{ .TypeName }}.
type {{ .OutputName }} struct {
	data []{{ .TypeName }}
}

// New{{ .OutputName }} returns a pointer to a new {{ .OutputName }} initialized with the specified elements.
func New{{ .OutputName }}(elems ...{{ .TypeName }}) *{{ .OutputName }} {
	s := new({{ .OutputName }})
	s.data = make([]{{ .TypeName }}, len(elems))
	for i := 0; i < len(elems); i++ {
		s.data[i] = elems[i]
	}
	return s
}

// Append adds the elements to the end of {{ .OutputName }}.
func (s *{{ .OutputName }}) Append(elems ...{{ .TypeName }}) *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	s.data = append(s.data, elems...)
	return s
}

// Prepend adds the elements to the beginning of {{ .OutputName }}.
func (s *{{ .OutputName }}) Prepend(elems ...{{ .TypeName }}) *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	s.data = append(elems, s.data...)
	return s
}

// At returns the element in {{ .OutputName }} at the specified index.
func (s *{{ .OutputName }}) At(index int) {{ .TypeName }} {
	if s.data == nil || len(s.data) == 0 {
		panic("{{ .OutputName }} does not contain any elements")
	}

	if index >= len(s.data) || index < 0 {
		panic(fmt.Sprintf("index %d outside the range of {{ .OutputName }}", index))
	}

	return s.data[index]
}

// Set sets the element of {{ .OutputName }} at the specified index.
func (s *{{ .OutputName }}) Set(index int, elem {{ .TypeName }}) *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	s.data[index] = elem
	return s
}

// Insert inserts the elements into {{ .OutputName }} at the specified index.
func (s *{{ .OutputName }}) Insert(index int, elems ...{{ .TypeName }}) *{{ .OutputName }} {
	if s == nil {
		return nil
	}

	// Grow the slice by the number of elements (using the zero value)
	var zero {{ .TypeName }}
	for i := 0; i < len(elems); i++ {
		s.data = append(s.data, zero)
	}

	// Use copy to move the upper part of the slice out of the way and open a hole.
	copy(s.data[index+len(elems):], s.data[index:])

	// Store the new values
	for i := 0; i < len(elems); i++ {
		s.data[index+i] = elems[i]
	}

	// Return the result.
	return s
}

// Remove removes the element from {{ .OutputName }} at the specified index.
func (s *{{ .OutputName }}) Remove(index int) *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	s.data = append(s.data[:index], s.data[index+1:]...)
	return s
}

// Filter removes elements from {{ .OutputName }} that do not satisfy the filter function.
func (s *{{ .OutputName }}) Filter(fn func(elem {{ .TypeName }}) bool) *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	data := s.data[:0]
	for _, elem := range s.data {
		if fn(elem) {
			data = append(data, elem)
		}
	}
	s.data = data
	return s
}

// Transform modifies each element of {{ .OutputName }} according to the specified function.
func (s *{{ .OutputName }}) Transform(fn func(elem {{ .TypeName }}) {{ .TypeName }}) *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	for i, elem := range s.data {
		s.data[i] = fn(elem)
	}
	return s
}

// Unique modifies {{ .OutputName }} to keep only the first occurrence of each element (removing any duplicates).
func (s *{{ .OutputName }}) Unique() *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	seen := make(map[{{ .TypeName }}]struct{})
	data := s.data[:0]
	for _, elem := range s.data {
		if _, ok := seen[elem]; !ok {
			data = append(data, elem)
			seen[elem] = struct{}{}
		}
	}
	s.data = data
	return s
}

// Reverse reverses the order of the elements of {{ .OutputName }}.
func (s *{{ .OutputName }}) Reverse() *{{ .OutputName }} {
	if s == nil {
		return nil
	}

	for i := len(s.data)/2 - 1; i >= 0; i-- {
		opp := len(s.data) - 1 - i
		s.Swap(i, opp)
	}

	return s
}

// Shuffle randomly shuffles the order of the elements in {{ .OutputName }}.
func (s *{{ .OutputName }}) Shuffle(seed int64) *{{ .OutputName }} {
	if s == nil {
		return nil
	}

	if seed == 0 {
		seed = time.Now().UnixNano()
	}

	r := rand.New(rand.NewSource(seed))
	r.Shuffle(s.Count(), s.Swap)

	return s
}

// Data returns the raw elements of {{ .OutputName }}.
func (s *{{ .OutputName }}) Data() []{{ .TypeName }} {
	if s == nil {
		return nil
	}
	return s.data
}

// Count returns the number of elements in {{ .OutputName }}.
func (s *{{ .OutputName }}) Count() int {
	return len(s.data)
}

// Len returns the number of elements in {{ .OutputName }} (alias for Count).
func (s *{{ .OutputName }}) Len() int {
	return s.Count()
}

// Swap swaps the elements in {{ .OutputName }} specified by the indices i and j.
func (s *{{ .OutputName }}) Swap(i, j int) {
	s.data[i], s.data[j] = s.data[j], s.data[i]
}
{{ if .Sortable }}
// Less returns true if the {{ .OutputName }} element at index i is less than the element at index j.
func (s *{{ .OutputName }}) Less(i, j int) bool {
	return s.data[i] < s.data[j]
}

// Sort sorts the elements of {{ .OutputName }} in increasing order.
func (s *{{ .OutputName }}) Sort() *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	sort.Sort(s)
	return s
}

// Min returns the smallest (least ordered) element in {{ .OutputName }}.
func (s *{{ .OutputName }}) Min() {{ .TypeName }} {
	if s.data == nil || len(s.data) == 0 {
		panic("{{ .OutputName }} does not contain any elements")
	}
	// start with the first value
	min := s.data[0]
	for _, elem := range s.data[1:] {
		if elem < min {
			min = elem
		}
	}
	return min
}

// Max returns the largest (greatest ordered) element in {{ .OutputName }}.
func (s *{{ .OutputName }}) Max() {{ .TypeName }} {
	if s.data == nil || len(s.data) == 0 {
		panic("{{ .OutputName }} does not contain any elements")
	}
	// start with the first value
	max := s.data[0]
	for _, elem := range s.data[1:] {
		if elem > max {
			max = elem
		}
	}
	return max
}
{{ end }}
// Clone performs a deep copy of {{ .OutputName }} and returns it
func (s *{{ .OutputName }}) Clone() *{{ .OutputName }} {
	if s == nil {
		return nil
	}
	s2 := new({{ .OutputName }})
	s2.data = make([]{{ .TypeName }}, len(s.data))
	copy(s2.data, s.data)
	return s2
}

// Equal returns true if the {{ .OutputName }} is logically equivalent to the specified {{ .OutputName }}.
func (s *{{ .OutputName }}) Equal(s2 *{{ .OutputName }}) bool {
	if s == s2 {
		return true
	}

	if s == nil || s2 == nil {
		return false // has to be false because s == s2 tested earlier
	}

	if len(s.data) != len(s2.data) {
		return false
	}

	for i, elem := range s.data {
		if elem != s2.data[i] {
			return false
		}
	}

	return true
}
`
