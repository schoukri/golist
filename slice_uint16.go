// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at 2020-04-08 00:13:35.635288 +0000 UTC.

package golist

import (
	"fmt"
	"math/rand"
	"sort"
	"time"
)

// SliceUint16 is a slice of type uint16.
type SliceUint16 struct {
	data []uint16
}

// NewSliceUint16 returns a pointer to a new SliceUint16 initialized with the specified elements.
func NewSliceUint16(elems ...uint16) *SliceUint16 {
	s := new(SliceUint16)
	s.data = make([]uint16, len(elems))
	for i := 0; i < len(elems); i++ {
		s.data[i] = elems[i]
	}
	return s
}

// Append adds the elements to the end of SliceUint16.
func (s *SliceUint16) Append(elems ...uint16) *SliceUint16 {
	if s == nil {
		return nil
	}
	s.data = append(s.data, elems...)
	return s
}

// Prepend adds the elements to the beginning of SliceUint16.
func (s *SliceUint16) Prepend(elems ...uint16) *SliceUint16 {
	if s == nil {
		return nil
	}
	s.data = append(elems, s.data...)
	return s
}

// At returns the element in SliceUint16 at the specified index.
func (s *SliceUint16) At(index int) uint16 {
	if s.data == nil || len(s.data) == 0 {
		panic("SliceUint16 does not contain any elements")
	}

	if index >= len(s.data) || index < 0 {
		panic(fmt.Sprintf("index %d outside the range of SliceUint16", index))
	}

	return s.data[index]
}

// Set sets the element of SliceUint16 at the specified index.
func (s *SliceUint16) Set(index int, elem uint16) *SliceUint16 {
	if s == nil {
		return nil
	}
	s.data[index] = elem
	return s
}

// Insert inserts the elements into SliceUint16 at the specified index.
func (s *SliceUint16) Insert(index int, elems ...uint16) *SliceUint16 {
	if s == nil {
		return nil
	}

	// Grow the slice by the number of elements (using the zero value)
	var zero uint16
	for i := 0; i < len(elems); i++ {
		s.data = append(s.data, zero)
	}

	// Use copy to move the upper part of the slice out of the way and open a hole.
	copy(s.data[index+len(elems):], s.data[index:])

	// Store the new values
	for i := 0; i < len(elems); i++ {
		s.data[index+i] = elems[i]
	}

	// Return the result.
	return s
}

// Remove removes the element from SliceUint16 at the specified index.
func (s *SliceUint16) Remove(index int) *SliceUint16 {
	if s == nil {
		return nil
	}
	s.data = append(s.data[:index], s.data[index+1:]...)
	return s
}

// Filter removes elements from SliceUint16 that do not satisfy the filter function.
func (s *SliceUint16) Filter(fn func(elem uint16) bool) *SliceUint16 {
	if s == nil {
		return nil
	}
	data := s.data[:0]
	for _, elem := range s.data {
		if fn(elem) {
			data = append(data, elem)
		}
	}
	s.data = data
	return s
}

// Transform modifies each element of SliceUint16 according to the specified function.
func (s *SliceUint16) Transform(fn func(elem uint16) uint16) *SliceUint16 {
	if s == nil {
		return nil
	}
	for i, elem := range s.data {
		s.data[i] = fn(elem)
	}
	return s
}

// Unique modifies SliceUint16 to keep only the first occurrence of each element (removing any duplicates).
func (s *SliceUint16) Unique() *SliceUint16 {
	if s == nil {
		return nil
	}
	seen := make(map[uint16]struct{})
	data := s.data[:0]
	for _, elem := range s.data {
		if _, ok := seen[elem]; !ok {
			data = append(data, elem)
			seen[elem] = struct{}{}
		}
	}
	s.data = data
	return s
}

// Reverse reverses the order of the elements of SliceUint16.
func (s *SliceUint16) Reverse() *SliceUint16 {
	if s == nil {
		return nil
	}

	for i := len(s.data)/2 - 1; i >= 0; i-- {
		opp := len(s.data) - 1 - i
		s.Swap(i, opp)
	}

	return s
}

// Shuffle randomly shuffles the order of the elements in SliceUint16.
func (s *SliceUint16) Shuffle(seed int64) *SliceUint16 {
	if s == nil {
		return nil
	}

	if seed == 0 {
		seed = time.Now().UnixNano()
	}

	r := rand.New(rand.NewSource(seed))
	r.Shuffle(s.Count(), s.Swap)

	return s
}

// Data returns the raw elements of SliceUint16.
func (s *SliceUint16) Data() []uint16 {
	if s == nil {
		return nil
	}
	return s.data
}

// Count returns the number of elements in SliceUint16.
func (s *SliceUint16) Count() int {
	return len(s.data)
}

// Len returns the number of elements in SliceUint16 (alias for Count).
func (s *SliceUint16) Len() int {
	return s.Count()
}

// Swap swaps the elements in SliceUint16 specified by the indices i and j.
func (s *SliceUint16) Swap(i, j int) {
	s.data[i], s.data[j] = s.data[j], s.data[i]
}
// Less returns true if the SliceUint16 element at index i is less than the element at index j.
func (s *SliceUint16) Less(i, j int) bool {
	return s.data[i] < s.data[j]
}

// Sort sorts the elements of SliceUint16 in increasing order.
func (s *SliceUint16) Sort() *SliceUint16 {
	if s == nil {
		return nil
	}
	sort.Sort(s)
	return s
}

// Min returns the smallest (least ordered) element in SliceUint16.
func (s *SliceUint16) Min() uint16 {
	if s.data == nil || len(s.data) == 0 {
		panic("SliceUint16 does not contain any elements")
	}
	// start with the first value
	min := s.data[0]
	for _, elem := range s.data[1:] {
		if elem < min {
			min = elem
		}
	}
	return min
}

// Max returns the largest (greatest ordered) element in SliceUint16.
func (s *SliceUint16) Max() uint16 {
	if s.data == nil || len(s.data) == 0 {
		panic("SliceUint16 does not contain any elements")
	}
	// start with the first value
	max := s.data[0]
	for _, elem := range s.data[1:] {
		if elem > max {
			max = elem
		}
	}
	return max
}

// Clone performs a deep copy of SliceUint16 and returns it
func (s *SliceUint16) Clone() *SliceUint16 {
	if s == nil {
		return nil
	}
	s2 := new(SliceUint16)
	s2.data = make([]uint16, len(s.data))
	copy(s2.data, s.data)
	return s2
}

// Equal returns true if the SliceUint16 is logically equivalent to the specified SliceUint16.
func (s *SliceUint16) Equal(s2 *SliceUint16) bool {
	if s == s2 {
		return true
	}

	if s == nil || s2 == nil {
		return false // has to be false because s == s2 tested earlier
	}

	if len(s.data) != len(s2.data) {
		return false
	}

	for i, elem := range s.data {
		if elem != s2.data[i] {
			return false
		}
	}

	return true
}
